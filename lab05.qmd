# Lab 5: Data Wrangling II {.unnumbered}

#### STOP: Section not yet completed!

## Package(s)

- [dplyr](https://dplyr.tidyverse.org)
- [stringr](https://stringr.tidyverse.org)
- [tidyr](https://tidyr.tidyverse.org)
- [forcats](https://forcats.tidyverse.org)
- [patchwork](https://patchwork.data-imaginist.com/index.html)
- [ggseqlogo](https://omarwagih.github.io/ggseqlogo/)

## Schedule

- 08.00 - 08.15: Exercises recap
- 08.15 - 08.30: Assignment walk-through
- 08.30 - 09.00: Introduction to Lab
- 09.00 - 09.15: Break
- 09.00 - 12.00: Exercises

## Learning Materials

_Please prepare the following materials_

- R4DS2e book: [Chapter 6: Data Tidying](https://r4ds.hadley.nz/data-tidy), [Chapter 15: Strings](https://r4ds.hadley.nz/strings), [Chapter 17: Factors](https://r4ds.hadley.nz/factors), [Chapter 20: Joins](https://r4ds.hadley.nz/joins)
- Video: [Tidy Data and tidyr](https://youtu.be/1ELALQlO-yM?t=465) - NB! Start at 7:45 and please note: `gather()` is now `pivot_longer()` and `spread()` is now `pivot_wider()`
- Video: [Working with Two Datasets: Binds, Set Operations, and Joins](https://www.youtube.com/watch?v=AuBgYDCg1Cg)
- Video: [stringr](https://www.youtube.com/watch?v=oIu5jK8DeX8&list=PLiC1doDIe9rDwsUhd3FtN1XGCV2ES1xZ2) (Playlist with 7 short videos)

## Learning Objectives

_A student who has met the objectives of the session will be able to:_

- Understand and apply the various `str_*()`-functions for string manipulation
- Understand and apply the family of `*_join()`-functions for combining data sets
- Understand and apply `pivot_wider()` and `pivot_longer()`
- Use factors in conjugation with plotting categorical data using `ggplot`

## Exercises

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library("tidyverse")
library("patchwork")
library("ggseqlogo")
```

## Intro

_We are upping the game here, so expect to get stuck at some of the questions. Remember - Discuss with your group how to solve the task, try to use google and naturally, the TAs and I are happy to nudge you in the right direction. Finally, remember... Have fun!_

Remember what you have worked on so far:

- RStudio
- rmarkdown
- ggplot
- filter
- arrange
- select
- mutate
- group_by
- summarise
- The pipe and creating pipelines
- stringr
- joining data
- pivotting data

_Think about this in the following as we will synthesise the above into an analysis below!_

## Getting Started

Today, we will work with data from a recent study of T-cell receptors and SARS-CoV-2:

- [A large-scale database of T-cell receptor beta (TCRβ) sequences and binding associations from natural and synthetic exposure to SARS-CoV-2](https://www.researchsquare.com/article/rs-51964/v1)

_Briefly, the virus invades the cells and takes over the intra-cellular machinery. Viral proteins are produced this way and small fragments of these called peptides are displayed on the surface of the cells by the Human Leukocyte Antigen (HLA). Here, they can be recognised by Cytotoxic T-Lymphocytes (CTLs) via the T-cell Receptor (TCR). This data contains cohort data on sequenced T-cell receptors (CDR3beta), viral antigens, HLA-haplotypes and clinical meta data._

Now:

1. Click on the link above, to go to the manuscript. Download the PDF and find the link to the data
1. Go to the data site (you may have to create and account, shouldn't take long)
1. Find and download the file `ImmuneCODE-MIRA-Release002.1.zip` (_CAREFUL, do not download the superseded files_)
1. Unpack, find the files `peptide-detail-ci.csv` and `subject-metadata.csv` and upload them to your `data`-folder in your [RStudio Cloud](https://rstudio.cloud) session
1. Finally, create yet another rmarkdown document for todays exercises

## Creating one data set from two data sets

Remember to load libraries first and then load the two data sets into variables `peptide_data` and `meta_data`

```{r echo=FALSE, message=FALSE, warning=FALSE}
#| eval: false
peptide_data <- read_csv(file = "data/peptide-detail-ci.csv", na = "N/A")
meta_data <- read_csv(file = "data/subject-metadata.csv", na = "N/A")
```

* __Q1: What are the dimensions of the `peptide_data` and `meta_data` respectively?__
* __Q2: Which variable is shared between the two data sets?__

Now, join the two data sets into to one data set called `peptide_meta_data` using the variable from Q2 and create a pipeline, including your joining code and this bit-of-code `select(-matches("D[RQP]"))` - Discuss in your group what this code actually does?

_Hint: play around with the code and change it to see what happens_

```{r echo=FALSE, eval=TRUE}
#| eval: false
peptide_meta_data = peptide_data %>% 
  full_join(meta_data,
            by = "Experiment") %>%
  select(-matches("D[RQP]"))
```

* __Q3: What are the dimensions of the joined data and how does this compare with Q1?__

## Exploraty Data Analysis I - The meta data

Let us ask the joined data (`peptide_meta_data`) some questions:

* __Q4: How many study participants are denoted `Healthy`?__

_Hint: First find out which variable identifies the study participants_

* __Q5: Actually, what are the study participants cohort groups and how many are in each?__

Now, create a histogram of the age of the study participants (_Remember to read any error-messages you may get_)

* __Q6: Take a look at the age variable to understand what happened?__
* __Q7: How are `NA`s denoted in the data?__

Remember you can get help on ANY R-function by typing `?function_name` in the console. Now, go back to where you read the data and see if you can fix the `NA`-problem. Once you have done that, re-create the histogram of the age of the study participants and play around with and understand the `binwidth`

```{r echo=FALSE, eval=FALSE}
#| eval: false
peptide_meta_data %>%
  ggplot(aes(x = Age)) +
  geom_histogram(binwidth = 1)
```

* __Q8: From the histogram, approximately how many are participants are 33 years old?__
* __Q9: Compare this number to the dimensions of the `meta_data` (see Q1), what happened?__

Using the dplyr verbs `select` and `distinct`, re-re-create the histogram of the age of the study participants and again, play around with and understand the `binwidth`

```{r echo=FALSE, eval=FALSE}
#| eval: false
peptide_meta_data %>%
  select(Experiment, Age) %>%
  distinct %>% 
  ggplot(aes(x = Age)) +
  geom_histogram(binwidth = 1)
```

* __Q10: From the histogram, how many are participants are 33 years old?__
* __Q11: How many of the participants are women? Men?__

Recreate the below visualisation

```{r echo=FALSE}
#| eval: false
pl1 = peptide_meta_data %>%
  select(Subject, Cohort, Age, Gender) %>%
  distinct %>%
  drop_na(Age, Gender) %>%
  ggplot(aes(x = Age,
             y = Cohort,
             fill = Gender)) +
  geom_boxplot(alpha = 0.5) +
  theme_classic(base_family = "Avenir",
                base_size = 12) +
  theme(legend.position = "none")
pl2 = peptide_meta_data %>%
  select(Subject, Cohort, Age, Gender) %>%
  distinct %>%
  drop_na(Age, Gender) %>%
  count(Cohort, Gender) %>% 
  ggplot(aes(x = n,
             y = Cohort,
             fill = Gender)) +
  geom_col(position = "dodge",
           alpha = 0.5) +
  theme_classic(base_family = "Avenir",
                base_size = 12) +
  theme(legend.position = "bottom")
pl1/pl2
```

_Before continuing to the next sections - Take some time to do some EDA, understand what is in the data, do some summaries, make some plots._

## Exploraty Data Analysis II - The Sequence Data

### Part I

The first thing we will take a look at here, is how the `Subject` `HLA`-alleles are distributed.

Subset the `peptide_meta_data` to the variables `Subject`, `HLA-X` and save it into `allele_data`, like so:

```{r echo=FALSE}
#| eval: false
allele_data = peptide_meta_data %>%
  select(Subject, contains("HLA")) %>%
  distinct
allele_data
```

Then convert the data and save it a new variable `allele_data_long` like so:

```{r echo=FALSE}
#| eval: false
allele_data_long = allele_data %>%
  select(Subject, contains("HLA")) %>%
  distinct %>%
  pivot_longer(cols = contains("HLA"),
               names_to = "Gene",
               values_to = "Allele")
allele_data_long
```

* __Q12: How many unique alleles are there?__

```{r echo=FALSE, eval=FALSE}
#| eval: false
allele_data_long %>%
  select(Allele) %>% 
  distinct %>% 
  nrow
```

Using the `View()`-function, look at the unique alleles - Notice something? Some alleles are e.g. `A*11:01`, whereas others are `B*51:01:02`. You can find information on why, by visiting [Nomenclature for Factors of the HLA System](http://hla.alleles.org/nomenclature/naming.html).

Long story short, we only want to include `Field 1` (allele group) and `Field 2` (Specific HLA protein). You have prepared the `stringr`-package for today. See if you can find a way to reduce e.g. `B*51:01:02` to `B*51:01` and then create a new variable `Allele_F_1_2` accordingly, while also removing the `...x` (where `x` is a number) subscripts from the `Gene`-variable (It is an artifact from having the data in a wide format, where you cannot have two variables with the same name) and removing any `NA`s

```{r echo=FALSE}
#| eval: false
allele_data_long = allele_data_long %>%
  mutate(Allele_F_1_2 = str_extract(Allele,
                                    pattern = "[ABC]\\*\\d+\\:\\d+"),
         Gene = str_remove(Gene,
                           pattern = "\\.{3}\\d+$")) %>% 
  drop_na
allele_data_long
```

* __Q13: How many unique alleles are there now?__

```{r echo=FALSE, eval=FALSE}
#| eval: false
allele_data_long %>% 
  select(Allele_F_1_2) %>% 
  distinct %>% 
  nrow
```

Try to run this `allele_data_long %>% group_by(Allele_F_1_2) %>% summarise(n = n())`

* __Q14: What are the top 3 alleles in terms of counts in the data?__

Now, run this code `allele_data_long %>% count(Allele_F_1_2)` and compare the output

* __Q15: _Per gene_ and in terms of percent, what are the 3 top alleles?__ Recreate this plot to answer the question <span style="color: red;">GROUP ASSIGNMENT</span>: 

```{r echo=FALSE, fig.align="center", fig.width=6, fig.height=6}
#| eval: false
allele_data_long %>%
  count(Gene, Allele_F_1_2) %>%
  group_by(Gene) %>%
  mutate(f = n / sum(n) * 100) %>%
  ungroup %>%
  ggplot(aes(x = f,
             y = fct_reorder(Allele_F_1_2, f))) +
  geom_col() +
  facet_wrap(vars(Gene), scales = "free_y", ncol = 3) +
  theme_minimal(base_family = "Avenir", base_size = 9) +
  labs(x = "Observed Allele Frequency (Within each gene) [%]",
       y = "Allele")
```

_Hint: What does `fct_reorder()´do?_

### Part II

Now, we will take a look into how the peptides bind to the HLA alleles.

First, create this data set from your `peptide_meta_data` data set and save in a new variable `sequence_data` (drop ANY rows contaning `NA`s ):

```{r echo=FALSE, eval=TRUE}
#| eval: false
sequence_data = peptide_meta_data %>% 
  select(`TCR BioIdentity`, `Amino Acids`, contains("HLA")) %>% 
  distinct %>% 
  drop_na
sequence_data
```

* __Q16: How many rows contained `NA`s?__
* __Q17: Is this data tidy? Explain why you answered yes or no__

Now, google `tidyr separate` and figure out how this works. Then fix the `TCR BioIdentity`-variable like so:

```{r echo=FALSE}
#| eval: false
sequence_data = sequence_data %>% 
  separate(`TCR BioIdentity`,
           into = c("CDR3b", "v_gene", "j_gene"),
           sep = "\\+")
sequence_data
```

* __Q18: Is this data tidy now? Explain why you answered yes or no__

Add a new variable `n_peptides` to your data set, which counts how many peptides are listed in `Amino Acids` variable

_Hint: Is there a package designed specifically for working with strings? If so perhaps it can be used for some trickery_

```{r echo=FALSE}
#| eval: false
sequence_data = sequence_data %>%
  mutate(n_peptides = str_count(`Amino Acids`, ",") + 1)
```

Create a histogram of distribution of the `n_peptides` variable

```{r echo=FALSE, eval=FALSE}
#| eval: false
sequence_data %>% 
  ggplot(aes(x = n_peptides)) +
  geom_histogram(binwidth = 1) +
  theme_minimal()
```

* __Q19: What is the maximum number of peptides seen for one observation?__

Now, Using `str_c()` and `seq()`, see if you can re-create this:

```{r echo=FALSE}
#| eval: false
str_c("peptide_", seq(from = 1, to = 5))
```

Then use the above to fix the `Amino Acids`-variable, like so:

```{r echo=FALSE, warning=FALSE, message=FALSE}
#| eval: false
sequence_data = sequence_data %>%
  separate(`Amino Acids`,
           into = str_c("peptide_", 1:13),
           sep = ",")
sequence_data
```
and convert the data and save it into `sequence_data_long`, like so:

```{r echo=FALSE}
#| eval: false
sequence_data_long = sequence_data %>%
  pivot_longer(contains("peptide_"),
               names_to = "peptide_n",
               values_to = "peptide")
sequence_data_long
```

* __Q20: How many observations are now in `sequence_data_long`?__

Remove `NA`s, fix the `HLA`-alleles, remove redundant columns and observations, like so:

```{r echo=FALSE}
#| eval: false
sequence_data_long = sequence_data_long %>%
  drop_na %>%
  pivot_longer(contains("HLA"),
               names_to = "tmp",
               values_to = "allele") %>%
  select(-n_peptides, -peptide_n, -tmp) %>%
  distinct
sequence_data_long
```

* __Q21: How many obserations now? Is this data tidy now?__

Finally, let us create a binding motif using the package `ggseqlogo` ([More info here](https://omarwagih.github.io/ggseqlogo/)). Subset the final `sequence_data_long`-data to `A*02:01` and unique observations of peptides of length 9

_Hint: You can pipe a vector of peptides into ggseqlogo, but perhaps you first need to `pull` that vector from your tibble?_

```{r echo=FALSE, fig.align="center", fig.height=3, fig.width=3}
#| eval: false
sequence_data_long %>%
  filter(allele == "A*02:01",
         str_length(peptide) == 9) %>%
  select(peptide) %>%
  distinct %>%
  pull(peptide) %>%
  ggseqlogo
```

* __Q22: Which positions in the peptide determines binding to HLA?__

_Hint: Recall your Introduction to Bioinformatics course_

Re-create this logo using the `CDR3b`-sequences and A*02:01-alleles:

```{r echo=FALSE, fig.align="center", fig.height=3, fig.width=3}
#| eval: false
sequence_data_long %>%
  filter(allele == "A*02:01",
         str_length(CDR3b) == 15) %>%
  select(CDR3b) %>%
  distinct %>%
  pull(CDR3b) %>%
  ggseqlogo
```

That's it for today - I know this overwhelming now, but commit to it and you WILL be plenty rewarded! I hope today was at least a glimpse into the flexibility and capabilities of using `tidyverse` for applied Bio Data Science
